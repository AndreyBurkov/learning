Обобщения появились в JDK 5

1. Компилятор НЕ создает разные версии для обобщенных классов. Он удаляет сведения 
об обобщенных типах, выполняя необходимые операции приведения типов, чтобы сделать 
поведение прикладного кода таким, как будто создана конкретная версия обобщенного класса.
Принцип стирания.
При компиляции прикладного кода Java все сведения об обобщенных типах удаляются (стираются).
Это означает, что параметры типа сначала заменяются их ограничивающим
типом, которым является тип Object, если никакого явного ограничения не указано.
Затем выполняется требуемое приведение типов, определяемое аргументами
типа, для обеспечения совместимости с типами, указанными в этих аргументах.
Компилятор также обеспечивает эту совместимость типов. Такой подход
к обобщениям означает, что никаких сведений о типах во время выполнения не
существует. Это просто механизм автоматической обработки исходного кода.

2. По существу, благодаря обобщениям ошибки,
возникающие во время выполнения, преобразуются в ошибки, обнаруживаемые
во время компиляции. В этом и заключается главное преимущество обобщений.

3. class Gen<T extends MyClass & Myinterface> { ... }
Здесь параметр типа T ограничивается классом MyClass и интерфейсом
Myinteface. Таким образом, любой тип, передаваемый параметру Т, должен
быть подклассом, производным от класса MyClass и реализующим интерфейс
Myinteface.

4. Пример вызова обобщенного статического метода:
public static <Т extends Comparable<T>, V extends Т> boolean isin(T х, V[] у) { }
Integer nums [] = { 1, 2, 3, 4, 5 };
GenMethDemo.<Integer, Integer>isin(2, nums)

5. Конструкторы также могут быть обобщенными, даже если их классы таковыми
не являются. 
class GenCons {
    private douЫe val;
    public <Т extends NumЬer> GenCons(T arg) {
        val = arg.douЬleValue();
    }
}

6. Обобщенный  интерфейс:
interface MinMax<T extends Comparable<T>> {}
Имплементация, если класс тоже обобщенный:
class MyClass<T extends Comparable<T>> implements MinMax<T> { } - ВЕРНО
class MyClass<T extends Comparable<T>> implements MinMax<T extends Comparable<T>> - НЕВЕРНО!!!
class MyClass implements MinMax<T> { } - НЕВЕРНО!!!
Имплементация заранее известного типа:
class MyClass implements MinMax<Integer> { } - ВЕРНО

7. Базовые типы не обеспечивают нужной безопасности. Это означает, что переменной
базового типа можно присвоить ссылку на любой тип объектов класса
Gen(обобщенный класс). Возможно и обратное: переменной конкретного типа Gen можно присвоить
ссылку на объект базового типа Gen. Но обе операции потенциально небезопасны,
поскольку они выполняются в обход механизма проверки типов.
Gen raw = new Gen(new DouЬle(98.6)); - не указан аргумент типа для Gen

8. В обобщенной иерархии любые аргументы
типа, требующиеся обобщенному суперклассу, должны передаваться всеми подклассами
вверх по иерархии.
class Gen2<T> extends Gen<T> {
  Gen2 (Т о) {
    super (о);
  }
}

9. Gen<Integer> iob1 = new Gen<>(1);
iob1 instanceof Gen<?> == true
iob1 instanceof Gen == true
iob1 instanceof Gen<String> == ERROR

10. Тип одного экземпляра обобщенного класса можно привести к другому только
в том случае, если они совместимы и их аргументы типа одинаковы.





ОГРАНИЧЕНИЯ:
1. Получить экземпляр по параметру типа нельзя:
class Gen<T> {
  T оЬ;
  Gen() {
    оЬ = new Т(); // Недопустимо!!! Компилятору неизвестен тип создаваемого объекта
  }
}

2. Ограничения на статические члены:
class Wrong<T> {
  static Т оЬ; //Неверно, нельзя создать статические переменные типа Т
  static Т getob() { // Неверно, ни в одном из статических методов нельзя использовать параметр типа Т
    return оЬ;
  }
}

3. Ограничения на обобщенные массивы:
Во-первых, нельзя создать экземпляр массива, тип элемента которого
определяется параметром типа. И, во-вторых, нельзя создать массив специфических
для типа обобщенных ссылок.
class Gen<T extends Number> {
  Т оЬ;
  Т vals[]; // Верно!
  Gen (T o, T[] nums) {
    оЬ = о;
    // Этот оператор неверен
    // vals = new T[10]; // нельзя создать массив объектов типа Т
    // Тем не менее этот оператор верен
    vals = nums; //можно присвоить ссылку существующему массиву
  }
}
Создать массив типа T нельзя потому, что тип Т не существует во время выполнения,
а следовательно, компилятор не в состоянии выяснить, массив элементов
какого именно типа требуется в действительности создавать.

class GenArrays {
  puЬlic static void main(String args[]) {
    Integer n[] = { 1, 2, 3, 4, 5 };
    Gen<Integer> iOb = new Gen<Integer>(50, n);
    // Нельзя создать массив специфических для типа обобщенных ссылок
    // Gen<Integer> gens[] = new Gen<Integer>[10]; // Неверно!
    Gen<?> gens[] = new Gen<?>[10]; // А это верно!
  }
}

4. Ограничения на обобщенные исключения:
Обобщенный класс не может расширять класс Throwable. Это означает, что
создать обобщенные классы исключений нельзя.