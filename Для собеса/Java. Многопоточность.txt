 1. Монитор можно рассматривать как маленький ящик, одновременно хранящий только один поток исполнения.
Для монитора в Java отсутствует отдельный класс вроде Monitor.
Вместо этого у каждого объекта имеется свой неявный монитор, вход в который осуществляется
автоматически, когда для этого объекта вызывается синхронизированный метод.
Когда поток исполнения находится в теле синхронизированного метода, ни один
другой поток исполнения не может вызвать какой-нибудь другой (или тот же) синхронизированный
метод для того же самого объекта. Вызов несинхранизованных методов разрешен.

2. Группа потоков исполнения - это структура данных, которая управляет состоянием
всей совокупности потоков исполнения в целом.

3. Для создания потока исполнения следует получить экземпляр
объекта типа Thread. В языке Java этой цели можно достичь следующими
двумя способами:
• реализовав интерфейс RunnaЫe;
• расширив класс Thread.

4. Синхронизация
Когда несколько потоков исполнения имеют доступ к одному совместно используемому
ресурсу, необходимо гарантировать, что ресурс будет одновременно
использован только одним потоком. Процесс, обеспечивающий такое поведение
потоков исполнения, называется синхронизацией.
Монитор - это объект, используемый в качестве взаимоисключающей блокировки.
Синхронизировать прикладной код можно двумя способами, предусматривающими 
использование ключевого слова synchronized.

5. Оператор synchronized
Допустим, что требуется синхронизировать доступ к объектам класса, НЕ предназначенного 
для многопоточного доступа. Это означает, что в данном классе НЕ применяются 
синхронизированные методы. Более того, класс написан сторонним разработчиком, и его 
исходный код недоступен, а следовательно, в объявление соответствующих методов данного 
класса нельзя ввести модификатор доступа synchronized. Как же синхронизировать доступ 
к объектам такого класса? К счастью, существует довольно простое решение этого вопроса:
заключить вызовы методов такого класса в блок оператора synchronized.
sуnсhrоnizеd(ссылка_на_синхронизируемый_объект) {
  // работа с синхронизованным объектом
}

6. В Java внедрен изящный механизм взаимодействия потоков исполнения с помощью методов 
wait(), notify() и notifyAll(). Эти методы реализованы как конечные в классе Object, 
поэтому они доступны всем классам. Все три метода могут быть вызваны только из
синхронизированного контекста. Правила применения этих методов достаточно просты, хотя 
с точки зрения вычислительной техники они принципиально прогрессивны. 
• Метод wait() вынуждает вызывающий поток исполнения уступить монитор
и перейти в состояние ожидания до тех пор, пока какой-нибудь другой поток
исполнения не войдет в тот же монитор и не вызовет метод notify().
• Метод notify() возобновляет исполнение потока, из которого был вызван
метод wait() для того же самого объекта.
• Метод notifyAll() возобновляет исполнение всех потоков, из которых
был вызван метод wait() для того же самого объекта. Одному из этих потоков
предоставляется доступ.

7. Получение состояния потока исполнения
Чтобы получить текущее состояние потока исполнения, достаточно вызвать метод getState():
Thread.State getState()
Следует иметь в виду, что состояние потока исполнения может измениться после вызова 
метода getState(). Поэтому в зависимости от обстоятельств состояние, полученное при 
вызове метода getState(), мгновение спустя может уже не отражать фактическое состояние 
потока исполнения. По этой и другим причинам метод getState() не предназначен для 
синхронизации потоков исполнения. Он служит прежде всего для отладки или профилирования 
характеристик потока во время выполнения.

8. Пaкeтjava.util.concurrent
В пакете java. util. concurrent определяются основные функциональные возможности, которые 
поддерживают альтернативные варианты встроенных способов синхронизации и взаимодействия 
между потоками исполнения. В этом пакете определяются следующие основные средства параллелизма.
• Синхронизаторы.
• Исполнители.
• Параллельные коллекции.
• Каркас Fork/Join Framework.

9. Синхронизаторы предоставляют высокоуровневые способы 
синхронизациивзаимодействия нескольких потоков.
• Semaphore - Реализует классический семафор.
  Семафор управляет доступом к общему ресурсу с помощью счетчика. Если счетчик больше 
  нуля, доступ разрешается, а если он равен нулю, то в доступе будет отказано.
  Semaphore(int число)
  Semaphore(int число, boolean способ)
  void acquire() throws InterruptedException
  void acquire(int число) throws InterruptedException
  void release ()
  void release(int число)
• CountDownLatch - Ожидает до тех пор, пока не произойдет определенное количество событий
  CountDownLatch(int число)
  void await() throws InterruptedException
  boolean await(long ожидание, TimeUnit единица_времени)  throws InterruptedException
  void countDown()
• CyclicBarrier - Позволяет группе потоков исполнения войти в режим ожиданияв предварительно 
  заданной точке выполнения
  CyclicBarrier(int количество_потоков)
  CyclicBarrier(int количество_потоков, Runnable действие)
  int await() throws InterruptedException, BrokenBarrierException
  int await(long ожидание, TimeUnit единица_времени) throws InterruptedException, BrokenBarrierException, TimeoutException
• Exchanger - Осуществляет обмен данными между двумя потоками исполнения 
  Exchanger<V>
  V exchange(V буфер) throws InterruptedException
  V exchange(V буфер, long ожидание, TimeUnit единица_времени) throws InterruptedException, TimeoutException
• Phaser - Синхронизирует потоки исполнения, проходящие через несколько фаз операции
  int register()
  int arrive()
  int arriveAndAwaitAdvance()
  int arriveAndDeregister()
  int getPhase()

10. Исполнители управляют исполнением потоков. На вершине иерархии исполнителей находится 
интерфейс Executor, предназначенный для запуска потока исполнения. Интерфейс ExecutorService 
расширяет интерфейс Executor и предоставляет методы, управляющие исполнением. Существуют 
следующие три реализации интерфейса ExecutorService в классах
ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool. 
В пакете java.util.concurrent определяется также служебный класс Executors, содержащий
несколько статических методов, упрощающих создание различных исполнителей.

11. Volatile
Ключевое слово volatile гарантирует, что каждый раз при чтении этой переменной поток будет
видеть самое последнее значение, записанное другим потокомю.
Volatile НЕ дает гарантии атомарности.

12. Проблемы многопоточности:
- race condition (состояние гонки) - это ошибка, возникающая в многопоточных или
  параллельных программах, когда результат выполнения программы зависит от того, в каком 
  порядке и как быстро выполняются потоки или процессы.
  Пример: два потока читаю одну переменную, и каждый поток увеличивает ее значение на 1.
  Ожидается, что переменная в результате будет увеличина на 2, но значение переменной
  увеличивается только на 1.
  Способы борьбы: любые виды синхронизации потоков (synchronized блок, оптимистические и 
  пессимистические блокировки, atomic типы, concurrent collections
- deadlock (взаимная блокировка) - это ситуация в многопоточное или параллельной программе,
  когда два или более потоков блокируют друг друга, ожидая ресурсы, которые уже захвачены
  друг другом. В результате ни один из потоков не может продолжить свое выполнение.

13. Оптимистические и пессимистические блокировки - это принципы к реализации блокировок.
Pessimistic Locking предполагает, что конфликты будут происходить, и поэтому поток или
транзакция захватывает ресурсы с самого начала, блокируя их до завершения своей работы.
Optimistic Locking предполагает, что конфликты будут редкими, и поэтому поток или 
транзакция НЕ блокирует ресурсы, а просто прверяет, не изменились ли данные с момента
их последнего чтения. Используется версионирование общего ресурса, чтобы понимать
менялся объект или нет.






























