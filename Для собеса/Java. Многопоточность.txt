 1. Монитор можно рассматривать как маленький ящик, одновременно хранящий только один поток исполнения.
Для монитора в Java отсутствует отдельный класс вроде Monitor.
Вместо этого у каждого объекта имеется свой неявный монитор, вход в который осуществляется
автоматически, когда для этого объекта вызывается синхронизированный метод.
Когда поток исполнения находится в теле синхронизированного метода, ни один
другой поток исполнения не может вызвать какой-нибудь другой (или тот же) синхронизированный
метод для того же самого объекта. Вызов несинхранизованных методов разрешен.

2. Группа потоков исполнения - это структура данных, которая управляет состоянием
всей совокупности потоков исполнения в целом.

3. Для создания потока исполнения следует получить экземпляр
объекта типа Thread. В языке Java этой цели можно достичь следующими
двумя способами:
• реализовав интерфейс Runnable;
• расширив класс Thread.

4. Синхронизация
Когда несколько потоков исполнения имеют доступ к одному совместно используемому
ресурсу, необходимо гарантировать, что ресурс будет одновременно
использован только одним потоком. Процесс, обеспечивающий такое поведение
потоков исполнения, называется синхронизацией.
Монитор - это объект, используемый в качестве взаимоисключающей блокировки.
Синхронизировать прикладной код можно двумя способами, предусматривающими 
использование ключевого слова synchronized.

5. Оператор synchronized
Допустим, что требуется синхронизировать доступ к объектам класса, НЕ предназначенного 
для многопоточного доступа. Это означает, что в данном классе НЕ применяются 
синхронизированные методы. Более того, класс написан сторонним разработчиком, и его 
исходный код недоступен, а следовательно, в объявление соответствующих методов данного 
класса нельзя ввести модификатор доступа synchronized. Как же синхронизировать доступ 
к объектам такого класса? К счастью, существует довольно простое решение этого вопроса:
заключить вызовы методов такого класса в блок оператора synchronized.
synchronized(ссылка_на_синхронизируемый_объект) {
  // работа с синхронизованным объектом
}

6. В Java внедрен изящный механизм взаимодействия потоков исполнения с помощью методов 
wait(), notify() и notifyAll(). Эти методы реализованы как конечные в классе Object, 
поэтому они доступны всем классам. Все три метода могут быть вызваны только из
синхронизированного контекста. Правила применения этих методов достаточно просты, хотя 
с точки зрения вычислительной техники они принципиально прогрессивны. 
• Метод wait() вынуждает вызывающий поток исполнения уступить монитор
и перейти в состояние ожидания до тех пор, пока какой-нибудь другой поток
исполнения не войдет в тот же монитор и не вызовет метод notify().
• Метод notify() возобновляет исполнение потока, из которого был вызван
метод wait() для того же самого объекта.
• Метод notifyAll() возобновляет исполнение всех потоков, из которых
был вызван метод wait() для того же самого объекта. Одному из этих потоков
предоставляется доступ.

7. Получение состояния потока исполнения.
Чтобы получить текущее состояние потока исполнения, достаточно вызвать метод getState():
Thread.State getState()
Следует иметь в виду, что состояние потока исполнения может измениться после вызова 
метода getState(). Поэтому в зависимости от обстоятельств состояние, полученное при 
вызове метода getState(), мгновение спустя может уже не отражать фактическое состояние 
потока исполнения. По этой и другим причинам метод getState() не предназначен для 
синхронизации потоков исполнения. Он служит прежде всего для отладки или профилирования 
характеристик потока во время выполнения.

8. Пакет java.util.concurrent.
В пакете java.util.concurrent определяются основные функциональные возможности, которые
поддерживают альтернативные варианты встроенных способов синхронизации и взаимодействия 
между потоками исполнения. В этом пакете определяются следующие основные средства параллелизма.
• Синхронизаторы.
• Исполнители.
• Параллельные коллекции.
• Каркас Fork/Join Framework.

9. Синхронизаторы предоставляют высокоуровневые способы  синхронизации взаимодействия нескольких потоков.
• Semaphore - Реализует классический семафор.
  Семафор управляет доступом к общему ресурсу с помощью счетчика. Если счетчик больше 
  нуля, доступ разрешается, а если он равен нулю, то в доступе будет отказано.
  Semaphore(int число)
  Semaphore(int число, boolean способ)
  void acquire() throws InterruptedException
  void acquire(int число) throws InterruptedException
  void release ()
  void release(int число)
• CountDownLatch - Ожидает до тех пор, пока не произойдет определенное количество событий
  CountDownLatch(int число)
  void await() throws InterruptedException
  boolean await(long ожидание, TimeUnit единица_времени)  throws InterruptedException
  void countDown()
• CyclicBarrier - Позволяет группе потоков исполнения войти в режим ожидания в предварительно
  заданной точке выполнения
  CyclicBarrier(int количество_потоков)
  CyclicBarrier(int количество_потоков, Runnable действие)
  int await() throws InterruptedException, BrokenBarrierException
  int await(long ожидание, TimeUnit единица_времени) throws InterruptedException, BrokenBarrierException, TimeoutException
• Exchanger - Осуществляет обмен данными между двумя потоками исполнения 
  Exchanger<V>
  V exchange(V буфер) throws InterruptedException
  V exchange(V буфер, long ожидание, TimeUnit единица_времени) throws InterruptedException, TimeoutException
• Phaser - Синхронизирует потоки исполнения, проходящие через несколько фаз операции
  int register()
  int arrive()
  int arriveAndAwaitAdvance()
  int arriveAndDeregister()
  int getPhase()

10. Исполнители управляют исполнением потоков. На вершине иерархии исполнителей находится 
интерфейс Executor, предназначенный для запуска потока исполнения. Интерфейс ExecutorService 
расширяет интерфейс Executor и предоставляет методы, управляющие исполнением. Существуют 
следующие три реализации интерфейса ExecutorService в классах
ThreadPoolExecutor, ScheduledThreadPoolExecutor и ForkJoinPool. 
В пакете java.util.concurrent определяется также служебный класс Executors, содержащий
несколько статических методов, упрощающих создание различных исполнителей.
Методы:
<T> Future<T> submit(Callable<T> task);  // дает возможность получить результат от выполнения потока в виде Future<T>
void execute(Runnable command);          // просто выполняет Runnable

11. Volatile
Ключевое слово volatile гарантирует, что каждый раз при чтении этой переменной поток будет
видеть самое последнее значение, записанное другим потоком.
Volatile НЕ дает гарантии атомарности.

12. Проблемы многопоточности:
- race condition (состояние гонки) - это ошибка, возникающая в многопоточных или
  параллельных программах, когда результат выполнения программы зависит от того, в каком 
  порядке и как быстро выполняются потоки или процессы.
  Пример: два потока читаю одну переменную, и каждый поток увеличивает ее значение на 1.
  Ожидается, что переменная в результате будет увеличена на 2, но значение переменной
  увеличивается только на 1.
  Способы борьбы: любые виды синхронизации потоков (synchronized блок, оптимистические и 
  пессимистические блокировки, atomic типы, concurrent collections
- deadlock (взаимная блокировка) - это ситуация в многопоточное или параллельной программе,
  когда два или более потоков блокируют друг друга, ожидая ресурсы, которые уже захвачены
  друг другом. В результате ни один из потоков не может продолжить свое выполнение.

13. Оптимистические и пессимистические блокировки - это принципы к реализации блокировок.
Pessimistic Locking предполагает, что конфликты будут происходить, и поэтому поток или
транзакция захватывает ресурсы с самого начала, блокируя их до завершения своей работы.
Optimistic Locking предполагает, что конфликты будут редкими, и поэтому поток или 
транзакция НЕ блокирует ресурсы, а просто проверяет, не изменились ли данные с момента
их последнего чтения. Используется версионирование общего ресурса, чтобы понимать
менялся объект или нет.




14. Атомарные операции

Алгоритм использует низкоуровневые машинные инструкции, такие как сравнение и замена (CAS, compare-and-swap,
что обеспечивает целостность данных и по ним уже существует большое количество исследований).

Типичная операция CAS работает с тремя операндами:
    Место в памяти для работы (M)
    Существующее ожидаемое значение (A) переменной
    Новое значение (B), которое необходимо установить

CAS атомарно обновляет M до B, но только если значение M совпадает с A, в противном случае никаких действий предприниматься не будет.



15. В Java `Future` и `CompletableFuture` являются частью пакета `java.util.concurrent`, и обе эти конструкции
предназначены для работы с асинхронными задачами, но они имеют разные функциональные возможности и особенности.

    ### Future

    `Future` представляет собой результат вычисления, которое будет доступно в будущем. Основные моменты:

    - **Получение результата**: Для получения результата выполнения задачи `Future` предоставляет метод `get()`.
      Этот метод блокирует текущий поток, пока результат не будет доступен.
    - **Отмена задачи**: Есть возможность отмены задачи с помощью метода `cancel()`.
    - **Проверка состояния**: Вы можете проверить, завершена ли задача, с помощью метода `isDone()`, и была ли она отменена с помощью `isCancelled()`.
    - **Ограниченные возможности**: `Future` не поддерживает цепочку обработки или обработку исключений в более функциональном стиле.

    Пример использования `Future`:

    import java.util.concurrent.Callable;
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.Future;

    public class FutureExample {
        public static void main(String[] args) {
            ExecutorService executor = Executors.newSingleThreadExecutor();

            Future<Integer> future = executor.submit(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    Thread.sleep(2000); // имитация долгой задачи
                    return 42;
                }
            });

            try {
                System.out.println("Результат: " + future.get()); // будет заблокировано до получения результата
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            } finally {
                executor.shutdown();
            }
        }
    }
    ```
    ```

    ### CompletableFuture

    `CompletableFuture` является более мощным и гибким вариантом, который расширяет возможности `Future`. Основные моменты:

    - **Асинхронное выполнение**: Вы можете создавать цепочки асинхронных операций с помощью методов,
      таких как `thenApply()`, `thenAccept()`, `thenRun()` и других.
    - **Обработка исключений**: `CompletableFuture` позволяет легко обрабатывать исключения с помощью методов `handle()` и `exceptionally()`.
    - **Составление**: Вы можете объединять несколько `CompletableFuture` с помощью методов `thenCombine()`, `allOf()`, `anyOf()` и других.
    - **Поддержка завершения**: Вы можете завершить `CompletableFuture` вручную с помощью метода `complete()`.

    Пример использования `CompletableFuture`:

    import java.util.concurrent.CompletableFuture;

    public class CompletableFutureExample {
        public static void main(String[] args) {
            CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {
                try {
                    Thread.sleep(2000); // имитация долгой задачи
                } catch (InterruptedException e) {
                    throw new IllegalStateException(e);
                }
                return 42;
            });

            completableFuture
                    .thenApply(result -> result * 2)
                    .thenAccept(result -> System.out.println("Результат: " + result))
                    .exceptionally(ex -> {
                        System.out.println("Произошла ошибка: " + ex.getMessage());
                        return null;
                    });

            // Даем время на выполнение асинхронной задачи
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    ### Заключение

    - Используйте `Future`, если вам нужно просто получить результат выполнения задачи и не требуется сложная обработка.
    - Используйте `CompletableFuture`, если вы хотите более гибкую и функциональную модель обработки асинхронных задач, включая возможность обработки последовательностей операций и исключений.





















