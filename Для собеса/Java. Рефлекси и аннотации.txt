//Простой тип аннотации
@interface MyAnno {
  String str();
  int val();
}



1. Объявление аннотации не может включать в себя ключевое слово extends. Но
все аннотации автоматически расширяют интерфейс Annotation. Это означает,
что Annotation является суперинтерфейсом для всех аннотаций. Он объявлен
в пакете java.lang.annotation. В интерфейсе Annotation переопределяются
методы hashCode (), equals () и toString (), определенные в классе Object. 
В нем также объявляется метод annotationType (), возвращающий объект типа 
Class, представляющий вызывающую аннотацию.



2. Аннотировать можно классы, методы, поля, параметры и константы 
перечислимого типа.



3. Правила удержания аннотаций.
Правила удержания определяют момент, когда аннотация отбрасывается. В Java 
определены три таких правила, инкапсулированные в перечисление
java.lang.annotation.RetentionPolicy. Это правила SOURCE, CLASS и RUNTIME.

Аннотации по правилу удержания SOURCE хранятся только в исходном файле и 
отбрасываются при компиляции. Аннотации по правилу удержания CLASS сохраняются
в файле с расширением .class во время компиляции. Но они недоступны для 
виртуальной машины JVM во время выполнения. Аннотации по правилу удержания 
RUNTIME сохраняются в файле с расширением .class во время компиляции и 
остаются доступными для виртуальной машины JVM во время выполнения. 
Это означает, что правило удержания RUNTIME предоставляет аннотации
наиболее высокую степень сохраняемости.
Если для аннотации не указано никакого правила удержания, то применяется
правило удержания CLASS.

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
  String str();
}



4. Получение экземпляра класса java.lang.Class тремя способами:
Class employeeClass1 = Class.forName("org.example.entity.Employee");
Class employeeClass2 = Employee.class;
Employee employee = new Employee();
Class employeeClass13 = employee.getClass(); 



5. Получение аннотаций во время выполнения с помощью рефлексии.
Рефлексия - это языковое средство для получения сведений о классе во время 
выполнения программы.



6. Аннотация @Target
Задает типы элементов, к которым можно применять аннотацию. Она предназначена
для применения только в качестве аннотации к другим аннотациям.
Аннотация @Target принимает один аргумент, который должен быть константой
из перечисления ElementType. Этот аргумент задает типы объявляемых элементов,
к которым можно применять аннотацию.
Объявляемый элемент, к которому можно применять
аннотацию:
ElementType.ANNOTATION_ТYPE - Другая аннотация
ElementType.CONSTRUCTOR     - Конструктор
ElementType.FIELD           - Поле
ElementType.LOCAL_VARIAВLE  - Локальная переменная
ElementType.МЕТНОD          - Метод
ElementType.РАСКАGЕ         - Пакет
ElementType.PARAМETER       - Параметр
ElementType.ТУРЕ            - Класс, интерфейс или перечисление
ElementType.ТУРЕ_РАRАМЕТЕR  - Параметр типа (добавлено в версии JDK 8)
ElementType.ТYPE_USE        - Использование типа (добавлено в версии JDK 8)

В аннотации @Target можно задать одно или несколько значений этих констант.
Чтобы задать несколько значений, их следует указать списком, заключив
в фигурные скобки. Например, чтобы указать, что аннотация применяется только
к полям и локальным переменным, достаточно определить следующую аннотацию:
@Target({ ElementТype.FIELD, ElementТype.LOCAL_VARIABLE })

В отсутствие обозначения @Target аннотацию можно применять к любому
объявляемому элементу, за исключением параметров типов. Именно поэтому зачастую
лучше указывать целевые константы явным образом, чтобы ясно обозначить
назначение аннотации.

7. Аннотация @Retention
Предназначена для применения только в качестве аннотации к другим аннотациям.
java.lang.annotation.RetentionPolicy. Это правила SOURCE, CLASS и RUNTIME.

8. Аннотация @Documented
Служит маркерным интерфейсом, сообщающим инструментальному средству
разработки, что аннотация должна быть документирована. Она предназначена
для применения только в качестве аннотации к объявлению другой аннотации.

9. Аннотация @Inherited
Это маркерная аннотация, которую можно применять только в другом объявлении
аннотации. Более того, она оказывает воздействие только на те аннотации,
которые будут применяться в объявлениях классов. Аннотация @Inherited обусловливает
наследование аннотации из суперкласса в подклассе. Так, если конкретная
аннотация запрашивается в подклассе, то в отсутствие этой аннотации
в подклассе проверяется ее присутствие в суперклассе. Если запрашиваемая аннотация
присутствует в суперклассе и аннотирована как @Inherited, то она будет
возвращена по запросу.

10. Аннотация @Оvеrridе
Это маркерная аннотация, которую можно применять только в методах. Метод,
аннотированный как @Override, должен переопределять метод из суперкласса.
Если он этого не сделает, во время компиляции возникнет ошибка. Эта аннотация
служит для гарантии того, что метод из суперкласса будет действительно переопределен,
а не просто перегружен.

11. Аннотация @Deprecated
Эта маркерная аннотация обозначает, что объявление устарело и должно быть
заменено более новой формой. Начиная с версии JDK 9, аннотация @Deprecated
позволяет также указать версию Java, с которой аннотируемый элемент считается
не рекомендованным к употреблению и подлежит удалению.

12. Аннотация @Functionalinterface
Эта маркерная аннотация предназначена для применения в интерфейсах. Она
обозначает, что аннотируемый интерфейс является функц,иональным, т.е. содержит
один и только один абстрактный метод. Функциональные интерфейсы применяются
в лямбда-выражениях.

13. Аннотация @SafeVarargs
Это маркерная аннотация применяется в методах и конструкторах. Она указывает
на отсутствие каких-нибудь небезопасных действий, связанных с параметром
переменной длины. Эта аннотация служит для подавления непроверяемых предупреждений,
возникающих в коде, который в остальном является безопасным, в связи с применением 
неовеществляемых типов аргументов переменной длины и получением
экземпляра параметризированного массива. (Неовеществляемый тип - это,
по существу, обобщенный тип).
Эту аннотацию следует применять только к методам или конструкторам с переменным
количеством аргументов, объявляемым как static или final.

14. Аннотация @SuppressWarnings
Эта аннотация обозначает, что следует подавить одно или несколько предупреждений,
которые могут быть выданы компилятором. Подавляемые предупреждения
указываются по имени в строковой форме.




15. Некоторые ограничения на аннотации
Существует ряд ограничений, налагаемых на объявления аннотаций. Вопервых,
одна аннотация не может наследовать другую. Во-вторых, все методы,
объявленные в аннотации, должны быть без параметров. Кроме того, они должны
возвращать один из перечисленных ниже типов:
• примитивный тип вроде int или douЫe;
• объект класса String или Class;
• перечислимый тип;
• тип другой аннотации;
• массив одного из предыдущих типов.
Аннотации не могут быть обобщенными. Иными словами, они не могут принимать
параметры типа. И наконец, при объявлении методов в аннотациях нельзя 
указывать оператор throws.














