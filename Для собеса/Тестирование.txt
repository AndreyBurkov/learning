Уровни тестирования:
1. Unit testing
   Тестирование небольшого компонента (класс, его методы)
2. Integration testing
   Тестирование нескольних компонентов приложения, те как маленькие units
   работают как один большой unit.
3. Acceptance tesing (Функциональное тестирование)
   Тестирование всего приложения в целом.



  JUnit 5 разбит на 3 основных под-проекта:
1. JUnit Platform
   Нужен, чтобы иметь возможность запускать тесты junit, IDE, инструменты 
   сборки или плагины должны включать и расширять API платформы. Он определяет 
   TestEngine API для разработки новых фреймворков тестирования, работающих на 
   платформе. Он также предоставляет средство запуска консоли для запуска 
   платформы из командной строки и создания подключаемых модулей для Gradle и Maven.
2. JUnit Jupiter
   Включает новые модели программирования и расширения для написания тестов. 
   В нем есть все новые аннотации junit и TestEngine реализация для запуска тестов, 
   написанных с этими аннотациями.
3. JUnit Vintage
   Его основная цель - поддерживать выполнение на платформе JUnit 5 тестов, 
   написанных для JUnit 3 и JUnit 4. Это есть обратная совместимость.


Жизненный цикл тестов:
@BeforeAll -> @BeforeEach -> @Test -> @AfterEach -> @AfterAll

@BeforeAll и @AfterAll вызываются лишь один раз до, и соответственно, после всех тестов.
@BeforeEach и @AfterEach вызываются до, и соответственно, после каждого теста.

Поведение жизненного цикла теста можно изменить с помощью API 
org.junit.jupiter.api.TestInstance, который позволяет изменить жизненный цикл по 
умолчанию (для тестового класса или метода тестирования). Это можно сделать, 
добавив в тестовый класс аннотацию @TestInstance (TestInstance.Lifecycle.PER_CLASS).
По умолчанию стоит @TestInstance(TestInstance.Lifecycle.PER_METHOD)


@BeforeEach - Аннотированный метод будет запускаться перед каждым тестовым методом в тестовом классе.
@AfterEach - Аннотированный метод будет запускаться после каждого тестового метода в тестовом классе.
@BeforeAll - Аннотированный метод будет запущен перед всеми тестовыми методами в тестовом классе. Этот метод должен быть статическим.
@AfterAll - Аннотированный метод будет запущен после всех тестовых методов в тестовом классе. Этот метод должен быть статическим.
@Test - Он используется, чтобы пометить метод как тест junit.
@DisplayName - Используется для предоставления любого настраиваемого отображаемого имени для тестового класса или тестового метода
@Disable - Он используется для отключения или игнорирования тестового класса или тестового метода из набора тестов.
@Nested - Используется для создания вложенных тестовых классов
@Tag - Пометьте методы тестирования или классы тестов тегами для обнаружения и фильтрации тестов.
@TestFactory - Отметить метод - это тестовая фабрика для динамических тестов.







-------------- Mockito: чем отличаются Mock и Spy?
https://otus.ru/nest/post/161/

Такой вопрос часто можно услышать на собеседовании, когда разговор заходит о unit-тестировании. 
Mockito позволяет создать объект-заглушку для интерфейса или класса. В случае Mock-объекта, единственное, 
что будут делать все методы такого объекта, если не определять их поведение, – возвращать значения 
по-умолчанию: void, default-ы для примитивов, пустые коллекции и null для всех остальных объектов. 
Но если какое-то поведение, требуемое для некоторых методов Mock-объекта, нам всё-таки нужно, 
мы можем его определить.
Помимо этого, Mockito позволяет «шпионить» за реальными объектами. В случае Spy-объекта, по-умолчанию 
будет исполняться оригинальное поведение методов объекта. Но как и в случае с Mock-объектами, 
их поведение можно переопределить.
Если мы хотим протестировать логику самого объекта и при этом не хотим внедрять какие-либо реальные 
сервисы и компоненты, то в данном случае стоит использовать вместо них Mock-объекты. 
В случае, если мы хотим протестировать всё вместе, за исключением каких-то специфических случаев, 
то стоит использовать Spy.












