https://struchkov.dev/blog/ru/lambda-expression-java/


1. Лямбда-выражения — это компактный способ записи анонимных функций в Java, который упрощает код.
Они появились в Java 8 и стали важной частью функционального программирования в языке.
Лямбда-выражения сокращают объем кода, устраняя необходимость в громоздких анонимных классах.



2. Ограничения лямбда-выражений.
 - Переменные должны быть effectively final: Переменные, которые используются внутри лямбды,
должны быть либо final, либо effectively final — это значит, что их значение не должно
изменяться после инициализации.

int threshold = 5;
processor.setLengthChecker(input -> {
    if (input.length() > threshold) {
        System.out.println("String is too long!");
    } else {
        System.out.println("String length is fine.");
    }
});
Переменная threshold не может изменяться после её объявления. Если бы вы попытались изменить
её значение после создания лямбды, это привело бы к ошибке компиляции. Лямбда захватывает
значения переменных только на момент их создания.

 - Лямбды не могут иметь состояния: Лямбда-выражения не могут содержать поля или изменяемые
внутренние переменные. В отличие от анонимных классов, лямбды не могут хранить своё состояние,
что ограничивает их в ситуациях, где требуется сохранять данные внутри объекта.

 - Лямбда-выражения не могут бросать проверяемые исключения. Если метод интерфейса не объявляет
исключений, лямбда не может напрямую бросать проверяемые исключения без их обработки.
Это требует оборачивать вызовы методов, которые могут бросать проверяемые исключения, в блок try-catch.
Integer x = 10;
Function<Integer, String> function = integer -> {
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    return String.valueOf(integer + x);
};

 - Ограниченная гибкость в наследовании: Лямбда-выражения не поддерживают наследование.
В отличие от анонимных классов, которые могут наследовать другие классы или реализовывать
несколько интерфейсов, лямбда всегда может реализовать только один функциональный интерфейс.

 - Отсутствие метаинформации: Лямбды не имеют имени и не могут содержать аннотации.



3. Системные функциональные интерфейсы.
В Java существует набор предопределённых системных функциональных интерфейсов в пакете java.util.function.
Эти интерфейсы покрывают типичные сценарии использования функциональных стилей программирования и позволяют
избежать создания собственных интерфейсов в большинстве случаев. Они широко используются в Stream API и Optional.

 - Function<T, R> — преобразование значений
Интерфейс Function<T, R> описывает функцию, которая принимает аргумент типа T и возвращает результат типа R.
Этот интерфейс полезен для задач, связанных с преобразованием данных.
Function<String, String> toUpperCase = s -> s.toUpperCase();
System.out.println(toUpperCase.apply("hello"));  // Output: HELLO

 - Predicate<T> — проверка условий
Predicate<T> представляет собой предикат, проверяющий условие, и возвращает true или false.
Используется для фильтрации данных или проверок различных условий.
Predicate<String> isLongerThan5 = s -> s.length() > 5;
System.out.println(isLongerThan5.test("hello"));  // Output: false

 - Consumer<T> — выполнение действий без возврата
Consumer<T> описывает операцию, которая принимает аргумент типа T, но не возвращает результат.
Это удобно для выполнения побочных действий, таких как вывод на экран или запись в файл.
Consumer<String> print = s -> System.out.println(s);
print.accept("Hello, World!");  // Output: Hello, World!

 - Supplier<T> — генерация значений
Supplier<T> — это функция, которая не принимает аргументов, но возвращает значение типа T.
Он полезен в тех случаях, когда необходимо отложенно генерировать или предоставлять значения.
Supplier<Double> randomSupplier = () -> Math.random();
System.out.println(randomSupplier.get());  // Output: (какое-то случайное число)

 - UnaryOperator<T> — унарные операции
UnaryOperator<T> — это подтип Function, который принимает и возвращает значения одного типа.
Он используется для операций, где вход и выход имеют один и тот же тип.
UnaryOperator<String> toUpperCase = s -> s.toUpperCase();
System.out.println(toUpperCase.apply("hello"));  // Output: HELLO

 - BinaryOperator<T> — бинарные операции
BinaryOperator<T> — это подтип BiFunction, который принимает два аргумента одного типа и
возвращает результат того же типа. Этот интерфейс часто используется для операций над числами
или другими значениями, где входные параметры и результат имеют один тип.
BinaryOperator<Integer> sum = (a, b) -> a + b;
System.out.println(sum.apply(5, 3));  // Output: 8



4. Ссылки на методы.
Ссылки на методы (method references) — это ещё один способ работы с функциональными интерфейсами в Java,
введённый вместе с лямбда-выражениями в Java 8.  С их помощью можно ссылаться на существующие методы или
конструкторы и передавать их в качестве аргументов.
Существует четыре типа ссылок на методы:
 - Ссылка на статический метод.
 - Ссылка на метод объекта.
 - Ссылка на метод класса через объект.
 - Ссылка на конструктор.

5. Ссылка на статический метод
Если метод является статическим, мы можем ссылаться на него с помощью синтаксиса ClassName::methodName.
   Function<Double, Double> sqrt = Math::sqrt;
   System.out.println(sqrt.apply(16.0));  // Output: 4.0
Этот пример показывает, что вместо лямбда-выражения x -> Math.sqrt(x) можно использовать ссылку на метод
Math::sqrt, так как лямбда просто вызывает статический метод sqrt.



6. Ссылка на метод объекта.
Если у нас есть объект, мы можем ссылаться на его метод с помощью синтаксиса object::methodName.
   String message = "Hello, World!";
   Supplier<Integer> stringLength = message::length;
   System.out.println(stringLength.get());  // Output: 13
Здесь лямбда () -> message.length() может быть заменена на ссылку на метод message::length, так как
метод length не принимает аргументов и возвращает длину строки.




